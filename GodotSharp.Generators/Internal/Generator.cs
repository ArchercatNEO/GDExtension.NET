using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace GodotSharp.Generators.Internal;

[Generator]
public partial class DynamicImportGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {        
        var attributedMethods = context.SyntaxProvider.ForAttributeWithMetadataName(
            "GodotSharp.DynamicImportAttribute",
            static (node, ct) => true,
            static (ctx, ct) =>
            {
                return ctx.TargetSymbol is IMethodSymbol methodSymbol
                ? new { Syntax = (MethodDeclarationSyntax)ctx.TargetNode, Symbol = methodSymbol }
                : null;
            }
        ).Where(member => member is not null);

        attributedMethods.Select((list, ct) =>
        {
            throw new DivideByZeroException();
            if (list != null)
            {

            }
            return true;
        });

        /*
         * private static delegate* unmanaged<{arguments}> <name>_icall;
         * public partial {returns} {name}({args})
         * {
         *   var arg1 = Marshal(arg1)
         *   ...
         *   {name}_icall(arg1, arg2 ...)
         * }
        */
        var generatedMethods = attributedMethods.Select((method, ct) =>
        {
                

            TypeSyntax icallType = FunctionPointerType(FunctionPointerCallingConvention(Token(SyntaxKind.UnmanagedKeyword)), FunctionPointerParameterList());
            VariableDeclaratorSyntax icallName = VariableDeclarator($"{method.Syntax.Identifier}_icall");
            VariableDeclarationSyntax icall = VariableDeclaration(icallType, [icallName]);
            FieldDeclarationSyntax icallField = FieldDeclaration(icall);
            
            BlockSyntax body = Block();
            MethodDeclarationSyntax methodImpl = method.Syntax.WithBody(body);
            
            ClassDeclarationSyntax containingClass = (ClassDeclarationSyntax)method.Syntax.Parent;
            containingClass = containingClass.AddMembers(icallField, methodImpl);
            NamespaceDeclarationSyntax containingNamespace  = (NamespaceDeclarationSyntax)containingClass.Parent;
            return containingNamespace;
        }).Select((classDef, ct) => classDef.ToString()).Collect();

        context.RegisterSourceOutput(generatedMethods, (ctx, source) =>
        {
            StringBuilder builder = new();
            
            builder.AppendLine("// <auto-generated/>");
            builder.Append(@"
            namespace GodotSharp
            {
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
                public sealed class DynamicImportAttribute : System.Attribute
                {
                    public string EntryPoint;
                }
            }
            ");

            foreach (string method in source)
            {
                builder.AppendLine(method);
            }

            ctx.AddSource("DynamicImportAttribute.g.cs", builder.ToString());
        });
    }
}